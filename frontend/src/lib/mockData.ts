// Mock data store with realistic CRM data
export interface Customer {
  id: string
  name: string
  email: string
  phone: string
  segment: string // Dynamic segment generated by AI analysis
  lifetime_value: number
  last_purchase: string
  location: string
  created_at: string
  tags: string[]
  engagement_score: number
  purchase_frequency: number
  preferred_channel: string
  customer_type: string // Dynamic business model
  market_reach: string // Dynamic market classification
  business_size: string // Dynamic size classification
  industry?: string
  avatar?: string
}

// Dynamic Segment Definition
export interface SegmentDefinition {
  id: string
  name: string
  description: string
  criteria: SegmentCriteria
  created_at: string
  last_updated: string
  customer_count: number
  avg_value: number
  patterns: string[]
}

export interface SegmentCriteria {
  rules: SegmentRule[]
  logic: 'AND' | 'OR'
}

export interface SegmentRule {
  field: keyof Customer
  operator: 'equals' | 'contains' | 'greater_than' | 'less_than' | 'between' | 'in_array'
  value: any
  weight: number // For AI confidence scoring
}

export interface Campaign {
  id: string
  name: string
  type: 'email' | 'sms' | 'social' | 'display' | 'search'
  status: 'draft' | 'active' | 'paused' | 'completed'
  budget: number
  spent: number
  start_date: string
  end_date: string
  target_audience: string
  impressions: number
  clicks: number
  conversions: number
  roi: number
  created_at: string
  description: string
}

export interface Insight {
  id: string
  type: 'prediction' | 'trend' | 'customer' | 'sales' | 'campaign' | 'alert' | 'success' | 'opportunity'
  title: string
  description: string
  confidence: number
  generated_at: string
  metrics?: Array<{ label: string; value: string }>
  actions?: Array<{ label: string; link: string }>
}

export interface Activity {
  id: string
  type: 'purchase' | 'customer' | 'campaign' | 'system' | 'success'
  title: string
  description: string
  timestamp: string
  link?: string
}

// AI-Powered Dynamic Segmentation Engine
class AISegmentationEngine {
  private segments: Map<string, SegmentDefinition> = new Map()
  
  constructor() {
    // Initialize with base learning patterns
    this.initializeBaseSegments()
  }
  
  private initializeBaseSegments() {
    // The AI starts with these base segments but will evolve them
    const baseSegments: SegmentDefinition[] = [
      {
        id: 'high_value_loyal',
        name: 'High-Value Loyalists',
        description: 'Customers with high lifetime value and consistent engagement',
        criteria: {
          rules: [
            { field: 'lifetime_value', operator: 'greater_than', value: 20000, weight: 0.4 },
            { field: 'engagement_score', operator: 'greater_than', value: 85, weight: 0.3 },
            { field: 'purchase_frequency', operator: 'greater_than', value: 10, weight: 0.3 }
          ],
          logic: 'AND'
        },
        created_at: new Date().toISOString(),
        last_updated: new Date().toISOString(),
        customer_count: 0,
        avg_value: 0,
        patterns: ['consistent purchasing', 'high engagement', 'premium spending']
      }
    ]
    
    baseSegments.forEach(segment => {
      this.segments.set(segment.id, segment)
    })
  }
  
  // Core AI function: Analyzes customer and generates/assigns segment
  generateSegmentForCustomer(customer: Customer, allCustomers: Customer[]): string {
    // Step 1: Try to match existing segments
    for (const [segmentId, segment] of this.segments) {
      if (this.customerMatchesSegment(customer, segment)) {
        return segmentId
      }
    }
    
    // Step 2: Generate new segment based on customer patterns
    const newSegment = this.discoverNewSegment(customer, allCustomers)
    if (newSegment) {
      this.segments.set(newSegment.id, newSegment)
      return newSegment.id
    }
    
    // Step 3: Fallback to intelligent classification
    return this.intelligentlyClassifyCustomer(customer)
  }
  
  private customerMatchesSegment(customer: Customer, segment: SegmentDefinition): boolean {
    const { rules, logic } = segment.criteria
    const matches = rules.map(rule => this.evaluateRule(customer, rule))
    
    return logic === 'AND' ? matches.every(m => m) : matches.some(m => m)
  }
  
  private evaluateRule(customer: Customer, rule: SegmentRule): boolean {
    const customerValue = customer[rule.field] as any
    
    switch (rule.operator) {
      case 'equals':
        return customerValue === rule.value
      case 'contains':
        return String(customerValue).toLowerCase().includes(String(rule.value).toLowerCase())
      case 'greater_than':
        return Number(customerValue) > Number(rule.value)
      case 'less_than':
        return Number(customerValue) < Number(rule.value)
      case 'between':
        return Number(customerValue) >= rule.value[0] && Number(customerValue) <= rule.value[1]
      case 'in_array':
        return Array.isArray(rule.value) && rule.value.includes(customerValue)
      default:
        return false
    }
  }
  
  // AI Pattern Discovery: Creates new segments when patterns emerge
  private discoverNewSegment(customer: Customer, allCustomers: Customer[]): SegmentDefinition | null {
    // Find similar customers with advanced pattern matching
    const similarCustomers = this.findSimilarCustomers(customer, allCustomers)
    
    // If we find 3+ similar customers without a segment, create one
    if (similarCustomers.length >= 3) {
      return this.createSegmentFromPattern(customer, similarCustomers)
    }
    
    return null
  }
  
  private findSimilarCustomers(target: Customer, allCustomers: Customer[]): Customer[] {
    return allCustomers.filter(customer => {
      if (customer.id === target.id) return false
      
      // Multi-dimensional similarity scoring
      const similarities = [
        this.valueSimilarity(target.lifetime_value, customer.lifetime_value),
        this.valueSimilarity(target.engagement_score, customer.engagement_score),
        this.categorySimilarity(target.industry || '', customer.industry || ''),
        this.categorySimilarity(target.customer_type, customer.customer_type),
        this.locationSimilarity(target.location, customer.location),
        this.tagSimilarity(target.tags, customer.tags)
      ]
      
      const avgSimilarity = similarities.reduce((a, b) => a + b, 0) / similarities.length
      return avgSimilarity > 0.7 // 70% similarity threshold
    })
  }
  
  private valueSimilarity(val1: number, val2: number): number {
    const diff = Math.abs(val1 - val2)
    const max = Math.max(val1, val2)
    return max === 0 ? 1 : Math.max(0, 1 - (diff / max))
  }
  
  private categorySimilarity(cat1: string, cat2: string): number {
    return cat1.toLowerCase() === cat2.toLowerCase() ? 1 : 0
  }
  
  private locationSimilarity(loc1: string, loc2: string): number {
    // Simple city/country matching - could be enhanced with geographic data
    const city1 = loc1.split(',')[0].trim().toLowerCase()
    const city2 = loc2.split(',')[0].trim().toLowerCase()
    return city1 === city2 ? 1 : 0.3 // Same city = 1, different city = 0.3
  }
  
  private tagSimilarity(tags1: string[], tags2: string[]): number {
    const intersection = tags1.filter(tag => tags2.includes(tag))
    const union = [...new Set([...tags1, ...tags2])]
    return union.length === 0 ? 0 : intersection.length / union.length
  }
  
  private createSegmentFromPattern(customer: Customer, similarCustomers: Customer[]): SegmentDefinition {
    const allCustomers = [customer, ...similarCustomers]
    
    // Generate intelligent segment name and description
    const patterns = this.identifyPatterns(allCustomers)
    const segmentName = this.generateSegmentName(patterns)
    const segmentId = segmentName.toLowerCase().replace(/[^a-z0-9]/g, '_')
    
    // Create criteria rules based on common patterns
    const rules = this.generateSegmentRules(allCustomers)
    
    const newSegment: SegmentDefinition = {
      id: segmentId,
      name: segmentName,
      description: this.generateSegmentDescription(patterns, allCustomers.length),
      criteria: { rules, logic: 'AND' },
      created_at: new Date().toISOString(),
      last_updated: new Date().toISOString(),
      customer_count: allCustomers.length,
      avg_value: allCustomers.reduce((sum, c) => sum + c.lifetime_value, 0) / allCustomers.length,
      patterns
    }
    
    return newSegment
  }
  
  private identifyPatterns(customers: Customer[]): string[] {
    const patterns: string[] = []
    
    // Analyze value patterns
    const avgValue = customers.reduce((sum, c) => sum + c.lifetime_value, 0) / customers.length
    if (avgValue > 50000) patterns.push('premium spending')
    else if (avgValue > 20000) patterns.push('high value')
    else if (avgValue < 5000) patterns.push('budget conscious')
    
    // Analyze engagement patterns
    const avgEngagement = customers.reduce((sum, c) => sum + c.engagement_score, 0) / customers.length
    if (avgEngagement > 90) patterns.push('highly engaged')
    else if (avgEngagement < 50) patterns.push('low engagement')
    
    // Analyze industry patterns
    const industries = customers.map(c => c.industry).filter(Boolean)
    const uniqueIndustries = [...new Set(industries)]
    if (uniqueIndustries.length === 1 && uniqueIndustries[0]) {
      patterns.push(`${uniqueIndustries[0].toLowerCase()} sector`)
    }
    
    // Analyze business type patterns
    const businessTypes = [...new Set(customers.map(c => c.customer_type))]
    if (businessTypes.length === 1) {
      patterns.push(`${businessTypes[0]} focused`)
    }
    
    // Analyze geographic patterns
    const locations = customers.map(c => c.location.split(',')[0].trim())
    const uniqueLocations = [...new Set(locations)]
    if (uniqueLocations.length === 1) {
      patterns.push(`${uniqueLocations[0]} based`)
    }
    
    return patterns
  }
  
  private generateSegmentName(patterns: string[]): string {
    // AI-generated creative names based on patterns
    const industryPattern = patterns.find(p => p.includes('sector'))
    const locationPattern = patterns.find(p => p.includes('based'))
    const businessPattern = patterns.find(p => p.includes('focused'))
    const valuePattern = patterns.find(p => p.includes('value') || p.includes('premium'))
    
    // Generate contextual name
    if (industryPattern && valuePattern) {
      const industry = industryPattern.replace(' sector', '').replace(/^\w/, c => c.toUpperCase())
      return `Premium ${industry} Leaders`
    }
    
    if (locationPattern && businessPattern) {
      const location = locationPattern.replace(' based', '').replace(/^\w/, c => c.toUpperCase())
      const business = businessPattern.replace(' focused', '').toUpperCase()
      return `${location} ${business} Champions`
    }
    
    if (patterns.includes('highly engaged')) {
      return 'Elite Engagement Circle'
    }
    
    if (patterns.includes('premium spending')) {
      return 'Luxury Market Segment'
    }
    
    // Fallback to pattern-based naming
    return patterns.slice(0, 2).map(p => p.split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ')).join(' & ') || 'Emerging Customer Segment'
  }
  
  private generateSegmentDescription(patterns: string[], customerCount: number): string {
    const patternText = patterns.length > 0 ? patterns.join(', ') : 'unique characteristics'
    return `AI-discovered segment of ${customerCount} customers sharing ${patternText}. This segment emerged from pattern analysis and represents a distinct customer group with similar behaviors and attributes.`
  }
  
  private generateSegmentRules(customers: Customer[]): SegmentRule[] {
    const rules: SegmentRule[] = []
    
    // Generate value-based rule
    const values = customers.map(c => c.lifetime_value).sort((a, b) => a - b)
    const minValue = values[0]
    const maxValue = values[values.length - 1]
    
    if (minValue > 1000) {
      rules.push({
        field: 'lifetime_value',
        operator: minValue === maxValue ? 'greater_than' : 'between',
        value: minValue === maxValue ? minValue * 0.8 : [minValue * 0.9, maxValue * 1.1],
        weight: 0.3
      })
    }
    
    // Generate engagement rule
    const engagements = customers.map(c => c.engagement_score)
    const avgEngagement = engagements.reduce((a, b) => a + b, 0) / engagements.length
    
    if (avgEngagement > 60 || avgEngagement < 40) {
      rules.push({
        field: 'engagement_score',
        operator: 'greater_than',
        value: Math.max(0, avgEngagement - 10),
        weight: 0.25
      })
    }
    
    // Generate industry rule if applicable
    const industries = customers.map(c => c.industry).filter(Boolean)
    const uniqueIndustries = [...new Set(industries)]
    if (uniqueIndustries.length === 1 && uniqueIndustries[0]) {
      rules.push({
        field: 'industry',
        operator: 'equals',
        value: uniqueIndustries[0],
        weight: 0.2
      })
    }
    
    // Generate business type rule
    const businessTypes = [...new Set(customers.map(c => c.customer_type))]
    if (businessTypes.length === 1) {
      rules.push({
        field: 'customer_type',
        operator: 'equals',
        value: businessTypes[0],
        weight: 0.15
      })
    }
    
    return rules
  }
  
  // Fallback intelligent classification when no patterns found
  private intelligentlyClassifyCustomer(customer: Customer): string {
    // AI-powered classification based on single customer attributes
    const classifiers = []
    
    // Value-based classification
    if (customer.lifetime_value > 100000) classifiers.push('ultra_premium')
    else if (customer.lifetime_value > 50000) classifiers.push('premium')
    else if (customer.lifetime_value > 20000) classifiers.push('high_value')
    else if (customer.lifetime_value > 5000) classifiers.push('standard')
    else classifiers.push('emerging')
    
    // Engagement-based classification
    if (customer.engagement_score > 90) classifiers.push('champion')
    else if (customer.engagement_score > 75) classifiers.push('advocate')
    else if (customer.engagement_score > 50) classifiers.push('engaged')
    else classifiers.push('passive')
    
    // Business context
    if (customer.industry) {
      classifiers.push(customer.industry.toLowerCase().replace(/\s+/g, '_'))
    }
    
    if (customer.customer_type) {
      classifiers.push(customer.customer_type)
    }
    
    // Purchase behavior
    if (customer.purchase_frequency > 20) classifiers.push('frequent_buyer')
    else if (customer.purchase_frequency < 3) classifiers.push('occasional_buyer')
    
    // Create intelligent segment name
    const primaryClassifier = classifiers[0]
    const secondaryClassifier = classifiers[1]
    
    return `${primaryClassifier}_${secondaryClassifier || 'customer'}`.replace(/[^a-z0-9_]/g, '')
  }
  
  // Get all discovered segments
  getAllSegments(): SegmentDefinition[] {
    return Array.from(this.segments.values())
  }
  
  // Update segment statistics
  updateSegmentStats(customers: Customer[]) {
    for (const segment of this.segments.values()) {
      const segmentCustomers = customers.filter(c => c.segment === segment.id)
      segment.customer_count = segmentCustomers.length
      segment.avg_value = segmentCustomers.length > 0 
        ? segmentCustomers.reduce((sum, c) => sum + c.lifetime_value, 0) / segmentCustomers.length 
        : 0
      segment.last_updated = new Date().toISOString()
    }
  }
}

class MockDataStore {
  private customers: Customer[] = []
  private campaigns: Campaign[] = []
  private insights: Insight[] = []
  private activities: Activity[] = []
  private aiSegmentationEngine: AISegmentationEngine

  constructor() {
    this.aiSegmentationEngine = new AISegmentationEngine()
    this.initializeData()
  }

  private initializeData() {
    // Initialize customers with raw data (segments will be generated dynamically)
    const rawCustomers = [
      {
        id: '1',
        name: 'Zhang Wei',
        email: 'zhang.wei@email.com',
        phone: '+86 138 0013 8000',
        lifetime_value: 25000,
        last_purchase: '2025-01-25',
        location: 'Shanghai',
        created_at: '2024-03-15',
        tags: ['high-value', 'luxury-buyer', 'frequent'],
        engagement_score: 95,
        purchase_frequency: 12,
        preferred_channel: 'email',
        customer_type: 'premium_b2c',
        market_reach: 'national',
        business_size: 'individual'
      },
      {
        id: '2',
        name: 'Li Ming',
        email: 'li.ming@email.com',
        phone: '+86 139 1234 5678',
        lifetime_value: 8500,
        last_purchase: '2025-01-20',
        location: 'Beijing',
        created_at: '2024-06-10',
        tags: ['consistent', 'seasonal'],
        engagement_score: 78,
        purchase_frequency: 6,
        preferred_channel: 'sms',
        customer_type: 'regular_b2c',
        market_reach: 'local',
        business_size: 'individual'
      },
      {
        id: '3',
        name: 'Wang Xiao',
        email: 'wang.xiao@email.com',
        phone: '+86 187 9876 5432',
        lifetime_value: 1200,
        last_purchase: '2025-01-28',
        location: 'Shenzhen',
        created_at: '2025-01-15',
        tags: ['new-customer', 'mobile-user'],
        engagement_score: 65,
        purchase_frequency: 2,
        preferred_channel: 'social',
        customer_type: 'emerging_b2c',
        market_reach: 'local',
        business_size: 'individual'
      },
      {
        id: '4',
        name: 'Chen Yu',
        email: 'chen.yu@email.com',
        phone: '+86 156 7890 1234',
        lifetime_value: 3200,
        last_purchase: '2024-09-15',
        location: 'Guangzhou',
        created_at: '2024-02-20',
        tags: ['dormant', 'needs-reactivation'],
        engagement_score: 25,
        purchase_frequency: 3,
        preferred_channel: 'email',
        customer_type: 'inactive_b2c',
        market_reach: 'local',
        business_size: 'individual'
      },
      {
        id: '5',
        name: 'Global Tech Solutions Ltd',
        email: 'procurement@globaltech.com',
        phone: '+1 415 555 0123',
        lifetime_value: 180000,
        last_purchase: '2025-01-22',
        location: 'San Francisco, USA',
        created_at: '2024-01-10',
        tags: ['enterprise', 'b2b', 'tech-sector', 'bulk-orders'],
        engagement_score: 92,
        purchase_frequency: 24,
        preferred_channel: 'email',
        customer_type: 'enterprise_b2b',
        market_reach: 'international',
        business_size: 'enterprise',
        industry: 'Technology'
      },
      {
        id: '6',
        name: 'Tokyo Retail Chain Co',
        email: 'orders@tokyoretail.jp',
        phone: '+81 3 1234 5678',
        lifetime_value: 95000,
        last_purchase: '2025-01-26',
        location: 'Tokyo, Japan',
        created_at: '2024-04-15',
        tags: ['retail', 'wholesale', 'asian-market', 'frequent'],
        engagement_score: 88,
        purchase_frequency: 18,
        preferred_channel: 'email',
        customer_type: 'wholesale_b2b',
        market_reach: 'international',
        business_size: 'large',
        industry: 'Retail'
      },
      {
        id: '7',
        name: 'Shanghai Medical Center',
        email: 'purchasing@shmc.cn',
        phone: '+86 21 5555 1234',
        lifetime_value: 65000,
        last_purchase: '2025-01-24',
        location: 'Shanghai',
        created_at: '2024-02-01',
        tags: ['healthcare', 'institutional', 'quality-focused', 'compliance'],
        engagement_score: 85,
        purchase_frequency: 15,
        preferred_channel: 'phone',
        customer_type: 'healthcare_b2b',
        market_reach: 'local',
        business_size: 'large',
        industry: 'Healthcare'
      },
      {
        id: '8',
        name: 'Beijing University',
        email: 'procurement@bju.edu.cn',
        phone: '+86 10 6666 7890',
        lifetime_value: 42000,
        last_purchase: '2025-01-21',
        location: 'Beijing',
        created_at: '2024-08-20',
        tags: ['education', 'government-funded', 'bulk-seasonal', 'research'],
        engagement_score: 76,
        purchase_frequency: 8,
        preferred_channel: 'email',
        customer_type: 'educational_b2g',
        market_reach: 'national',
        business_size: 'large',
        industry: 'Education'
      },
      {
        id: '9',
        name: 'StartupHub Ventures',
        email: 'admin@startuphub.io',
        phone: '+86 755 8888 9999',
        lifetime_value: 15000,
        last_purchase: '2025-01-27',
        location: 'Shenzhen',
        created_at: '2024-11-01',
        tags: ['startup', 'tech', 'growth-stage', 'price-sensitive'],
        engagement_score: 82,
        purchase_frequency: 12,
        preferred_channel: 'social',
        customer_type: 'startup_b2b',
        market_reach: 'local',
        business_size: 'small',
        industry: 'Technology'
      },
      {
        id: '10',
        name: 'National Retail Group',
        email: 'sourcing@nrg.cn',
        phone: '+86 400 123 4567',
        lifetime_value: 320000,
        last_purchase: '2025-01-23',
        location: 'Multiple Cities, China',
        created_at: '2023-12-15',
        tags: ['national-chain', 'volume-buyer', 'seasonal-peaks', 'omnichannel'],
        engagement_score: 94,
        purchase_frequency: 36,
        preferred_channel: 'phone',
        customer_type: 'enterprise_b2b',
        market_reach: 'national',
        business_size: 'enterprise',
        industry: 'Retail'
      },
      {
        id: '11',
        name: 'Local Boutique Store',
        email: 'owner@localboutique.cn',
        phone: '+86 21 7777 8888',
        lifetime_value: 8200,
        last_purchase: '2025-01-26',
        location: 'Shanghai',
        created_at: '2024-05-10',
        tags: ['local-business', 'boutique', 'premium-focus', 'personal-service'],
        engagement_score: 87,
        purchase_frequency: 10,
        preferred_channel: 'phone',
        customer_type: 'boutique_b2b',
        market_reach: 'local',
        business_size: 'small',
        industry: 'Retail'
      },
      {
        id: '12',
        name: 'Government Procurement Office',
        email: 'procurement@gov.cn',
        phone: '+86 10 1234 5678',
        lifetime_value: 150000,
        last_purchase: '2025-01-20',
        location: 'Beijing',
        created_at: '2024-03-01',
        tags: ['government', 'tender-based', 'compliance-strict', 'long-cycle'],
        engagement_score: 70,
        purchase_frequency: 6,
        preferred_channel: 'email',
        customer_type: 'government_b2g',
        market_reach: 'national',
        business_size: 'enterprise',
        industry: 'Government'
      }
    ]

    // 🚀 DYNAMIC AI SEGMENTATION: Generate segments for all customers
    this.customers = rawCustomers.map(customer => ({
      ...customer,
      segment: this.aiSegmentationEngine.generateSegmentForCustomer(customer as Customer, rawCustomers as Customer[])
    })) as Customer[]

    // Update segment statistics after all customers are processed
    this.aiSegmentationEngine.updateSegmentStats(this.customers)

    // Initialize campaigns
    this.campaigns = [
      {
        id: '1',
        name: 'Summer Sale 2025',
        type: 'email',
        status: 'active',
        budget: 50000,
        spent: 32000,
        start_date: '2025-01-15',
        end_date: '2025-02-28',
        target_audience: 'VIP and Regular customers',
        impressions: 125000,
        clicks: 8750,
        conversions: 525,
        roi: 185,
        created_at: '2025-01-10',
        description: 'Seasonal promotion targeting high-value customers'
      },
      {
        id: '2',
        name: 'New Customer Welcome',
        type: 'sms',
        status: 'active',
        budget: 15000,
        spent: 8900,
        start_date: '2025-01-01',
        end_date: '2025-12-31',
        target_audience: 'New customers (first 30 days)',
        impressions: 45000,
        clicks: 6750,
        conversions: 890,
        roi: 245,
        created_at: '2024-12-20',
        description: 'Automated welcome series for new registrations'
      },
      {
        id: '3',
        name: 'Reactivation Campaign',
        type: 'social',
        status: 'paused',
        budget: 25000,
        spent: 12500,
        start_date: '2025-01-20',
        end_date: '2025-02-20',
        target_audience: 'Inactive customers',
        impressions: 67000,
        clicks: 3350,
        conversions: 145,
        roi: 78,
        created_at: '2025-01-15',
        description: 'Win-back campaign for dormant customers'
      }
    ]

    // Initialize insights
    this.insights = [
      {
        id: '1',
        type: 'prediction',
        title: 'Customer Churn Risk Identified',
        description: '15 VIP customers show high churn probability based on purchase patterns',
        confidence: 89,
        generated_at: new Date().toISOString(),
        metrics: [
          { label: 'Risk Level', value: 'High' },
          { label: 'Potential Revenue Loss', value: '¥380,000' }
        ],
        actions: [
          { label: 'Create Retention Campaign', link: '/campaigns/create' },
          { label: 'View Customer List', link: '/customers?segment=at-risk' }
        ]
      },
      {
        id: '2',
        type: 'opportunity',
        title: 'Cross-sell Opportunity',
        description: 'Premium accessories show 65% purchase probability for luxury bag buyers',
        confidence: 92,
        generated_at: new Date(Date.now() - 300000).toISOString(),
        metrics: [
          { label: 'Potential Customers', value: '47' },
          { label: 'Estimated Revenue', value: '¥125,000' }
        ],
        actions: [
          { label: 'Create Cross-sell Campaign', link: '/campaigns/create' }
        ]
      },
      {
        id: '3',
        type: 'trend',
        title: 'Mobile Usage Surge',
        description: 'Mobile purchases increased 34% this week, optimize mobile experience',
        confidence: 96,
        generated_at: new Date(Date.now() - 600000).toISOString(),
        metrics: [
          { label: 'Mobile Growth', value: '+34%' },
          { label: 'Mobile Revenue Share', value: '67%' }
        ],
        actions: [
          { label: 'Mobile Analytics', link: '/analytics/mobile' }
        ]
      }
    ]

    // Initialize activities
    this.activities = [
      {
        id: '1',
        type: 'customer',
        title: 'New VIP Customer Registered',
        description: 'Liu Mei joined as VIP member with ¥50,000 initial purchase',
        timestamp: new Date().toISOString(),
        link: '/customers/5'
      },
      {
        id: '2',
        type: 'purchase',
        title: 'Large Order Completed',
        description: 'Zhang Wei completed ¥25,000 luxury handbag purchase',
        timestamp: new Date(Date.now() - 900000).toISOString(),
        link: '/customers/1'
      },
      {
        id: '3',
        type: 'campaign',
        title: 'Campaign Performance Alert',
        description: 'Summer Sale campaign exceeded ROI target by 25%',
        timestamp: new Date(Date.now() - 1800000).toISOString(),
        link: '/campaigns/1'
      },
      {
        id: '4',
        type: 'system',
        title: 'AI Model Updated',
        description: 'Customer segmentation model retrained with new data',
        timestamp: new Date(Date.now() - 3600000).toISOString()
      }
    ]
  }

  // Customer methods
  getCustomers(filters: { search?: string; segment?: string } = {}) {
    let filtered = [...this.customers]
    
    if (filters.search) {
      const query = filters.search.toLowerCase()
      filtered = filtered.filter(c => 
        c.name.toLowerCase().includes(query) ||
        c.email.toLowerCase().includes(query) ||
        c.location.toLowerCase().includes(query)
      )
    }
    
    if (filters.segment && filters.segment !== 'all') {
      filtered = filtered.filter(c => c.segment === filters.segment)
    }
    
    return filtered
  }

  getCustomerStats() {
    // 🚀 DYNAMIC STATS: Generate stats based on discovered segments
    const dynamicSegmentStats: { [key: string]: number } = {}
    const allSegments = this.aiSegmentationEngine.getAllSegments()
    
    // Count customers in each discovered segment
    allSegments.forEach(segment => {
      dynamicSegmentStats[segment.id] = this.customers.filter(c => c.segment === segment.id).length
    })
    
    // Generate business type stats dynamically
    const businessTypeStats: { [key: string]: number } = {}
    const uniqueBusinessTypes = [...new Set(this.customers.map(c => c.customer_type))]
    uniqueBusinessTypes.forEach(type => {
      businessTypeStats[type] = this.customers.filter(c => c.customer_type === type).length
    })
    
    // Generate market reach stats dynamically
    const marketReachStats: { [key: string]: number } = {}
    const uniqueMarketReaches = [...new Set(this.customers.map(c => c.market_reach))]
    uniqueMarketReaches.forEach(reach => {
      marketReachStats[reach] = this.customers.filter(c => c.market_reach === reach).length
    })
    
    const stats = {
      total: this.customers.length,
      // Dynamic segment counts
      ...dynamicSegmentStats,
      // Dynamic business type counts
      ...businessTypeStats,
      // Dynamic market reach counts
      ...marketReachStats,
      // Core metrics
      totalRevenue: this.customers.reduce((sum, c) => sum + c.lifetime_value, 0),
      avgEngagement: Math.round(this.customers.reduce((sum, c) => sum + c.engagement_score, 0) / this.customers.length),
      // AI-discovered segments metadata
      discoveredSegments: allSegments.length,
      segmentDetails: allSegments.map(segment => ({
        id: segment.id,
        name: segment.name,
        count: segment.customer_count,
        avgValue: segment.avg_value,
        patterns: segment.patterns
      }))
    }
    return stats
  }

  createCustomer(customer: Omit<Customer, 'id' | 'created_at' | 'segment'>) {
    // Create customer without segment first
    const newCustomerWithoutSegment = {
      ...customer,
      id: Date.now().toString(),
      created_at: new Date().toISOString()
    }
    
    // 🚀 DYNAMIC SEGMENTATION: Generate segment for new customer
    const segment = this.aiSegmentationEngine.generateSegmentForCustomer(
      newCustomerWithoutSegment as Customer, 
      this.customers
    )
    
    const newCustomer: Customer = {
      ...newCustomerWithoutSegment,
      segment
    }
    
    this.customers.push(newCustomer)
    
    // 🔄 EVOLUTION TRACKING: Update all segment statistics
    this.aiSegmentationEngine.updateSegmentStats(this.customers)
    
    // Add activity for segment evolution tracking
    this.addActivity({
      type: 'system',
      title: 'New Customer Segmented',
      description: `${newCustomer.name} automatically assigned to segment: ${segment}. AI discovered ${this.aiSegmentationEngine.getAllSegments().length} total segments.`
    })
    
    return newCustomer
  }

  updateCustomer(id: string, updates: Partial<Customer>) {
    const index = this.customers.findIndex(c => c.id === id)
    if (index !== -1) {
      const oldCustomer = this.customers[index]
      const updatedCustomer = { ...oldCustomer, ...updates }
      
      // 🚀 RE-SEGMENTATION: Check if customer should be moved to different segment
      const newSegment = this.aiSegmentationEngine.generateSegmentForCustomer(
        updatedCustomer,
        this.customers
      )
      
      const finalCustomer = { ...updatedCustomer, segment: newSegment }
      this.customers[index] = finalCustomer
      
      // 🔄 EVOLUTION TRACKING: Update segment statistics
      this.aiSegmentationEngine.updateSegmentStats(this.customers)
      
      // Track segment changes
      if (oldCustomer.segment !== newSegment) {
        this.addActivity({
          type: 'system',
          title: 'Customer Re-segmented',
          description: `${finalCustomer.name} moved from "${oldCustomer.segment}" to "${newSegment}" based on updated data patterns.`
        })
      }
      
      return finalCustomer
    }
    return null
  }

  deleteCustomer(id: string) {
    const index = this.customers.findIndex(c => c.id === id)
    if (index !== -1) {
      this.customers.splice(index, 1)
      return true
    }
    return false
  }

  // Campaign methods
  getCampaigns(filters: { search?: string; status?: string } = {}) {
    let filtered = [...this.campaigns]
    
    if (filters.search) {
      const query = filters.search.toLowerCase()
      filtered = filtered.filter(c => 
        c.name.toLowerCase().includes(query) ||
        c.description.toLowerCase().includes(query)
      )
    }
    
    if (filters.status && filters.status !== 'all') {
      filtered = filtered.filter(c => c.status === filters.status)
    }
    
    return filtered
  }

  getCampaignStats() {
    return {
      total: this.campaigns.length,
      active: this.campaigns.filter(c => c.status === 'active').length,
      totalBudget: this.campaigns.reduce((sum, c) => sum + c.budget, 0),
      totalSpent: this.campaigns.reduce((sum, c) => sum + c.spent, 0),
      avgROI: Math.round(this.campaigns.reduce((sum, c) => sum + c.roi, 0) / this.campaigns.length),
      totalImpressions: this.campaigns.reduce((sum, c) => sum + c.impressions, 0),
      totalConversions: this.campaigns.reduce((sum, c) => sum + c.conversions, 0),
      conversionRate: Math.round((this.campaigns.reduce((sum, c) => sum + c.conversions, 0) / this.campaigns.reduce((sum, c) => sum + c.clicks, 1)) * 100 * 100) / 100
    }
  }

  createCampaign(campaign: Omit<Campaign, 'id' | 'created_at'>) {
    const newCampaign: Campaign = {
      ...campaign,
      id: Date.now().toString(),
      created_at: new Date().toISOString()
    }
    this.campaigns.push(newCampaign)
    return newCampaign
  }

  updateCampaign(id: string, updates: Partial<Campaign>) {
    const index = this.campaigns.findIndex(c => c.id === id)
    if (index !== -1) {
      this.campaigns[index] = { ...this.campaigns[index], ...updates }
      return this.campaigns[index]
    }
    return null
  }

  updateCampaignStatus(id: string, status: Campaign['status']) {
    return this.updateCampaign(id, { status })
  }

  duplicateCampaign(id: string) {
    const campaign = this.campaigns.find(c => c.id === id)
    if (campaign) {
      const duplicate = {
        ...campaign,
        id: Date.now().toString(),
        name: `${campaign.name} (Copy)`,
        status: 'draft' as const,
        spent: 0,
        impressions: 0,
        clicks: 0,
        conversions: 0,
        roi: 0,
        created_at: new Date().toISOString()
      }
      this.campaigns.push(duplicate)
      return duplicate
    }
    return null
  }

  // Insights methods
  getInsights() {
    // Generate fresh insights based on current data
    this.generateFreshInsights()
    return [...this.insights].sort((a, b) => 
      new Date(b.generated_at).getTime() - new Date(a.generated_at).getTime()
    )
  }

  private generateFreshInsights() {
    const customerStats = this.getCustomerStats() as any
    
    // Generate insights based on current data
    const dynamicInsights = [
      {
        id: `insight-${Date.now()}-1`,
        type: 'trend' as const,
        title: `${customerStats.vip} VIP Customers Driving Revenue`,
        description: `VIP customers represent ${((customerStats.vip / customerStats.total) * 100).toFixed(1)}% of your base but likely generate 60%+ of revenue`,
        confidence: 94,
        generated_at: new Date().toISOString(),
        metrics: [
          { label: 'VIP Customers', value: customerStats.vip.toString() },
          { label: 'Revenue Share', value: '~60%' }
        ],
        actions: [
          { label: 'VIP Retention Campaign', link: '/campaigns' },
          { label: 'View VIP Customers', link: '/customers?segment=vip' }
        ]
      },
      {
        id: `insight-${Date.now()}-2`,
        type: 'opportunity' as const,
        title: `${customerStats.inactive} Customers Ready for Reactivation`,
        description: 'Inactive customers show patterns suggesting they can be won back with targeted campaigns',
        confidence: 87,
        generated_at: new Date(Date.now() - 60000).toISOString(),
        metrics: [
          { label: 'Inactive Count', value: customerStats.inactive.toString() },
          { label: 'Reactivation Rate', value: '25%' }
        ],
        actions: [
          { label: 'Create Reactivation Campaign', link: '/campaigns' }
        ]
      }
    ]

    // Replace some old insights with fresh ones
    this.insights = [
      ...dynamicInsights,
      ...this.insights.slice(0, 3)
    ].slice(0, 5)
  }

  // Activities methods
  getActivities() {
    return [...this.activities].sort((a, b) => 
      new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()
    )
  }

  addActivity(activity: Omit<Activity, 'id' | 'timestamp'>) {
    const newActivity: Activity = {
      ...activity,
      id: Date.now().toString(),
      timestamp: new Date().toISOString()
    }
    this.activities.unshift(newActivity)
    // Keep only last 50 activities
    if (this.activities.length > 50) {
      this.activities = this.activities.slice(0, 50)
    }
    return newActivity
  }

  // Dashboard data
  getDashboardStats() {
    const customerStats = this.getCustomerStats()
    const campaignStats = this.getCampaignStats()
    
    return {
      totalCustomers: customerStats.total,
      activeToday: Math.floor(customerStats.total * 0.15), // Simulate 15% daily active
      totalRevenue: customerStats.totalRevenue,
      growthRate: 8.5, // Static growth rate
      newCustomersToday: 3,
      campaignsActive: campaignStats.active,
      avgEngagement: customerStats.avgEngagement,
      conversionRate: campaignStats.conversionRate,
      user_name: 'Business Owner' // Default greeting name
    }
  }

  // Enhanced Chart Data
  getRevenueChartData() {
    return {
      labels: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
      revenue: [385000, 426000, 398000, 512000, 478000, 534000, 612000, 589000, 645000, 698000, 756000, 823000],
      target: [400000, 420000, 440000, 460000, 480000, 500000, 520000, 540000, 560000, 580000, 600000, 620000],
      growth: [8.5, 12.3, -6.6, 28.6, -6.6, 11.7, 14.6, -3.8, 9.5, 8.2, 8.3, 8.9]
    }
  }

  getCustomerSegmentChartData() {
    const segments = this.aiSegmentationEngine.getAllSegments()
    return {
      labels: segments.map(s => s.name),
      data: segments.map(s => s.customer_count),
      avgValues: segments.map(s => s.avg_value),
      colors: [
        'rgba(245, 158, 11, 0.8)',
        'rgba(59, 130, 246, 0.8)',
        'rgba(16, 185, 129, 0.8)',
        'rgba(139, 92, 246, 0.8)',
        'rgba(239, 68, 68, 0.8)',
        'rgba(6, 182, 212, 0.8)',
        'rgba(236, 72, 153, 0.8)',
        'rgba(34, 197, 94, 0.8)'
      ].slice(0, segments.length)
    }
  }

  getCampaignPerformanceChartData() {
    return {
      labels: this.campaigns.map(c => c.name),
      roi: this.campaigns.map(c => c.roi),
      spent: this.campaigns.map(c => c.spent),
      conversions: this.campaigns.map(c => c.conversions),
      colors: [
        'rgba(59, 130, 246, 0.8)',
        'rgba(16, 185, 129, 0.8)',
        'rgba(245, 158, 11, 0.8)',
        'rgba(139, 92, 246, 0.8)',
        'rgba(239, 68, 68, 0.8)'
      ]
    }
  }

  getEngagementData() {
    return {
      labels: ['Email Opens', 'Click Rate', 'Social Shares', 'Website Visits', 'App Usage', 'Purchase Rate'],
      currentMonth: [85, 72, 68, 91, 76, 83],
      previousMonth: [78, 68, 62, 87, 71, 79],
      industry_avg: [70, 65, 55, 75, 60, 65]
    }
  }

  getGeographicData() {
    const locationStats = {} as any
    this.customers.forEach(customer => {
      const city = customer.location.split(',')[0].trim()
      locationStats[city] = (locationStats[city] || 0) + 1
    })
    
    return {
      labels: Object.keys(locationStats),
      data: Object.values(locationStats),
      revenue: Object.keys(locationStats).map(city => 
        this.customers
          .filter(c => c.location.includes(city))
          .reduce((sum, c) => sum + c.lifetime_value, 0)
      )
    }
  }

  getRealTimeMetrics() {
    // Simulate real-time data for the last 24 hours
    const hours = Array.from({ length: 24 }, (_, i) => `${i}:00`)
    const visitors = Array.from({ length: 24 }, () => Math.floor(Math.random() * 100) + 50)
    const sales = Array.from({ length: 24 }, () => Math.floor(Math.random() * 10000) + 5000)
    const orders = Array.from({ length: 24 }, () => Math.floor(Math.random() * 20) + 5)
    
    return {
      hours,
      visitors,
      sales,
      orders,
      current: {
        visitors: visitors[visitors.length - 1],
        sales: sales[sales.length - 1],
        orders: orders[orders.length - 1],
        conversion: ((orders[orders.length - 1] / visitors[visitors.length - 1]) * 100).toFixed(1)
      }
    }
  }

  // AI Performance Metrics
  getAIPerformanceData() {
    return {
      predictionAccuracy: 94.2,
      modelConfidence: 89.7,
      dataQuality: 92.1,
      insightRelevance: 87.4,
      userSatisfaction: 91.3,
      segmentationAccuracy: 96.8,
      churnPrediction: 88.9,
      revenueForecasting: 93.5
    }
  }
}

// Singleton instance
export const mockDataStore = new MockDataStore()